import{_ as a,o as t,c as r,ag as o}from"./chunks/framework.DM0yugQT.js";const p=JSON.parse('{"title":"SDK Watcher Integration","description":"","frontmatter":{},"headers":[],"relativePath":"sdk-watcher.md","filePath":"sdk-watcher.md","lastUpdated":1771875003000}'),i={name:"sdk-watcher.md"};function c(n,e,d,h,s,l){return t(),r("div",null,[...e[0]||(e[0]=[o('<h1 id="sdk-watcher-integration" tabindex="-1">SDK Watcher Integration <a class="header-anchor" href="#sdk-watcher-integration" aria-label="Permalink to &quot;SDK Watcher Integration&quot;">​</a></h1><p>The SDK service exposes a watcher integration that surfaces granular auth updates without forcing a full reload. This document explains the queue contract, how the service consumes updates, and how high-frequency change bursts are handled.</p><h2 id="update-queue-contract" tabindex="-1">Update Queue Contract <a class="header-anchor" href="#update-queue-contract" aria-label="Permalink to &quot;Update Queue Contract&quot;">​</a></h2><ul><li><code>watcher.AuthUpdate</code> represents a single credential change. <code>Action</code> may be <code>add</code>, <code>modify</code>, or <code>delete</code>, and <code>ID</code> carries the credential identifier. For <code>add</code>/<code>modify</code> the <code>Auth</code> payload contains a fully populated clone of the credential; <code>delete</code> may omit <code>Auth</code>.</li><li><code>WatcherWrapper.SetAuthUpdateQueue(chan&lt;- watcher.AuthUpdate)</code> wires the queue produced by the SDK service into the watcher. The queue must be created before the watcher starts.</li><li>The service builds the queue via <code>ensureAuthUpdateQueue</code>, using a buffered channel (<code>capacity=256</code>) and a dedicated consumer goroutine (<code>consumeAuthUpdates</code>). The consumer drains bursts by looping through the backlog before reacquiring the select loop.</li></ul><h2 id="watcher-behaviour" tabindex="-1">Watcher Behaviour <a class="header-anchor" href="#watcher-behaviour" aria-label="Permalink to &quot;Watcher Behaviour&quot;">​</a></h2><ul><li><code>internal/watcher/watcher.go</code> keeps a shadow snapshot of auth state (<code>currentAuths</code>). Each filesystem or configuration event triggers a recomputation and a diff against the previous snapshot to produce minimal <code>AuthUpdate</code> entries that mirror adds, edits, and removals.</li><li>Updates are coalesced per credential identifier. If multiple changes occur before dispatch (e.g., write followed by delete), only the final action is sent downstream.</li><li>The watcher runs an internal dispatch loop that buffers pending updates in memory and forwards them asynchronously to the queue. Producers never block on channel capacity; they just enqueue into the in-memory buffer and signal the dispatcher. Dispatch cancellation happens when the watcher stops, guaranteeing goroutines exit cleanly.</li></ul><h2 id="high-frequency-change-handling" tabindex="-1">High-Frequency Change Handling <a class="header-anchor" href="#high-frequency-change-handling" aria-label="Permalink to &quot;High-Frequency Change Handling&quot;">​</a></h2><ul><li>The dispatch loop and service consumer run independently, preventing filesystem watchers from blocking even when many updates arrive at once.</li><li>Back-pressure is absorbed in two places: <ul><li>The dispatch buffer (map + order slice) coalesces repeated updates for the same credential until the consumer catches up.</li><li>The service channel capacity (256) combined with the consumer drain loop ensures several bursts can be processed without oscillation.</li></ul></li><li>If the queue is saturated for an extended period, updates continue to be merged, so the latest state is eventually applied without replaying redundant intermediate states.</li></ul><h2 id="usage-checklist" tabindex="-1">Usage Checklist <a class="header-anchor" href="#usage-checklist" aria-label="Permalink to &quot;Usage Checklist&quot;">​</a></h2><ol><li>Instantiate the SDK service (builder or manual construction).</li><li>Call <code>ensureAuthUpdateQueue</code> before starting the watcher to allocate the shared channel.</li><li>When the <code>WatcherWrapper</code> is created, call <code>SetAuthUpdateQueue</code> with the service queue, then start the watcher.</li><li>Provide a reload callback that handles configuration updates; auth deltas will arrive via the queue and are applied by the service automatically through <code>handleAuthUpdate</code>.</li></ol><p>Following this flow keeps auth changes responsive while avoiding full reloads for every edit.</p>',11)])])}const g=a(i,[["render",c]]);export{p as __pageData,g as default};
