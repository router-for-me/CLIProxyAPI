import{_ as a,o as t,c,ag as d}from"./chunks/framework.DM0yugQT.js";const p=JSON.parse('{"title":"SDK Watcher集成说明","description":"","frontmatter":{},"headers":[],"relativePath":"sdk-watcher_FA.md","filePath":"sdk-watcher_FA.md","lastUpdated":1771822208000}'),o={name:"sdk-watcher_FA.md"};function r(l,e,h,i,u,n){return t(),c("div",null,[...e[0]||(e[0]=[d('<h1 id="sdk-watcher集成说明" tabindex="-1">SDK Watcher集成说明 <a class="header-anchor" href="#sdk-watcher集成说明" aria-label="Permalink to &quot;SDK Watcher集成说明&quot;">​</a></h1><p>本文档介绍SDK服务与文件监控器之间的增量更新队列，包括接口契约、高频变更下的处理策略以及接入步骤。</p><h2 id="更新队列契约" tabindex="-1">更新队列契约 <a class="header-anchor" href="#更新队列契约" aria-label="Permalink to &quot;更新队列契约&quot;">​</a></h2><ul><li><code>watcher.AuthUpdate</code>描述单条凭据变更，<code>Action</code>可能为<code>add</code>、<code>modify</code>或<code>delete</code>，<code>ID</code>是凭据标识。对于<code>add</code>/<code>modify</code>会携带完整的<code>Auth</code>克隆，<code>delete</code>可以省略<code>Auth</code>。</li><li><code>WatcherWrapper.SetAuthUpdateQueue(chan&lt;- watcher.AuthUpdate)</code>用于将服务侧创建的队列注入watcher，必须在watcher启动前完成。</li><li>服务通过<code>ensureAuthUpdateQueue</code>创建容量为256的缓冲通道，并在<code>consumeAuthUpdates</code>中使用专职goroutine消费；消费侧会主动“抽干”积压事件，降低切换开销。</li></ul><h2 id="watcher行为" tabindex="-1">Watcher行为 <a class="header-anchor" href="#watcher行为" aria-label="Permalink to &quot;Watcher行为&quot;">​</a></h2><ul><li><code>pkg/llmproxy/watcher/watcher.go</code>维护<code>currentAuths</code>快照，文件或配置事件触发后会重建快照并与旧快照对比，生成最小化的<code>AuthUpdate</code>列表。</li><li>以凭据ID为维度对更新进行合并，同一凭据在短时间内的多次变更只会保留最新状态（例如先写后删只会下发<code>delete</code>）。</li><li>watcher内部运行异步分发循环：生产者只向内存缓冲追加事件并唤醒分发协程，即使通道暂时写满也不会阻塞文件事件线程。watcher停止时会取消分发循环，确保协程正常退出。</li></ul><h2 id="高频变更处理" tabindex="-1">高频变更处理 <a class="header-anchor" href="#高频变更处理" aria-label="Permalink to &quot;高频变更处理&quot;">​</a></h2><ul><li>分发循环与服务消费协程相互独立，因此即便短时间内出现大量变更也不会阻塞watcher事件处理。</li><li>背压通过两级缓冲吸收： <ul><li>分发缓冲（map + 顺序切片）会合并同一凭据的重复事件，直到消费者完成处理。</li><li>服务端通道的256容量加上消费侧的“抽干”逻辑，可平稳处理多个突发批次。</li></ul></li><li>当通道长时间处于高压状态时，缓冲仍持续合并事件，从而在消费者恢复后一次性应用最新状态，避免重复处理无意义的中间状态。</li></ul><h2 id="接入步骤" tabindex="-1">接入步骤 <a class="header-anchor" href="#接入步骤" aria-label="Permalink to &quot;接入步骤&quot;">​</a></h2><ol><li>实例化SDK Service（构建器或手工创建）。</li><li>在启动watcher之前调用<code>ensureAuthUpdateQueue</code>创建共享通道。</li><li>watcher通过工厂函数创建后立刻调用<code>SetAuthUpdateQueue</code>注入通道，然后再启动watcher。</li><li>Reload回调专注于配置更新；认证增量会通过队列送达，并由<code>handleAuthUpdate</code>自动应用。</li></ol><p>遵循上述流程即可在避免全量重载的同时保持凭据变更的实时性。</p>',11)])])}const _=a(o,[["render",r]]);export{p as __pageData,_ as default};
