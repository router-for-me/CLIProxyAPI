import{_ as o,o as i,c as t,ag as l}from"./chunks/framework.DM0yugQT.js";const m=JSON.parse('{"title":"Issue Wave CPB-0138..0147 Lane 1 Plan","description":"","frontmatter":{},"headers":[],"relativePath":"planning/reports/issue-wave-cpb-0138-0147-lane-1.md","filePath":"planning/reports/issue-wave-cpb-0138-0147-lane-1.md","lastUpdated":1771814022000}'),a={name:"planning/reports/issue-wave-cpb-0138-0147-lane-1.md"};function r(c,e,d,s,n,u){return i(),t("div",null,[...e[0]||(e[0]=[l('<h1 id="issue-wave-cpb-0138-0147-lane-1-plan" tabindex="-1">Issue Wave CPB-0138..0147 Lane 1 Plan <a class="header-anchor" href="#issue-wave-cpb-0138-0147-lane-1-plan" aria-label="Permalink to &quot;Issue Wave CPB-0138..0147 Lane 1 Plan&quot;">​</a></h1><h2 id="scope" tabindex="-1">Scope <a class="header-anchor" href="#scope" aria-label="Permalink to &quot;Scope&quot;">​</a></h2><ul><li>Lane: <code>1</code></li><li>Target items: <code>CPB-0138</code>..<code>CPB-0147</code></li><li>Worktree: <code>/Users/kooshapari/temp-PRODVERCEL/485/kush/cliproxyapi-plusplus</code></li><li>Date: 2026-02-23</li><li>Focus: document implementable deltas and verification commands for these ten items; other lanes can ignore unrelated edits in the repository.</li></ul><h2 id="per-item-plan" tabindex="-1">Per-Item Plan <a class="header-anchor" href="#per-item-plan" aria-label="Permalink to &quot;Per-Item Plan&quot;">​</a></h2><h3 id="cpb-0138-define-non-subprocess-integration-path" tabindex="-1">CPB-0138 Define non-subprocess integration path <a class="header-anchor" href="#cpb-0138-define-non-subprocess-integration-path" aria-label="Permalink to &quot;CPB-0138 Define non-subprocess integration path&quot;">​</a></h3><ul><li>Status: <code>planned</code></li><li>Implementation deltas: <ul><li>Extend <code>docs/sdk-usage.md</code> so the <code>Integration Contract</code> section walks through the recommended in-process <code>sdk/cliproxy.NewBuilder()</code> lifecycle, the HTTP fallback (<code>/v1/*</code>, <code>/v0/management/config</code>), and the capability/version negotiation probes (<code>/health</code>, <code>/v1/models</code>, <code>remote-management.secret-key</code>).</li><li>Add a troubleshooting row that highlights the version sniffing steps and points to the HTTP fallback endpoints exposed by <code>cmd/server</code> and <code>sdk/api/handlers</code>.</li><li>Capture the benchmark plan called for in the board by recording the pre-change <code>task test:baseline</code> results and explaining that the same command will be rerun after the implementable delta.</li></ul></li><li>Planned files: <ul><li><code>docs/sdk-usage.md</code></li><li><code>docs/troubleshooting.md</code></li></ul></li><li>Notes: keep the focus on documentation and observable experience; no deep runtime refactor is scheduled yet.</li></ul><h3 id="cpb-0139-gemini-cli-rollout-safety-guardrails" tabindex="-1">CPB-0139 Gemini CLI rollout safety guardrails <a class="header-anchor" href="#cpb-0139-gemini-cli-rollout-safety-guardrails" aria-label="Permalink to &quot;CPB-0139 Gemini CLI rollout safety guardrails&quot;">​</a></h3><ul><li>Status: <code>planned</code></li><li>Implementation deltas: <ul><li>Add table-driven API contract tests in <code>pkg/llmproxy/executor/gemini_cli_executor_test.go</code> that exercise missing credential fields, legacy vs. new parameter mixes, and the <code>statusErr</code> path that surfaces the upstream <code>额度获取失败</code> message.</li><li>Extend <code>pkg/llmproxy/auth/gemini/gemini_auth_test.go</code> with fixtures that simulate malformed tokens (missing <code>refresh_token</code>, expired credential struct) so the CLI can surface <code>请检查凭证状态</code> before hitting production.</li><li>Reference the new guardrails in <code>docs/troubleshooting.md</code> (Gemini CLI section) and the <code>Gemini</code> quickstart so operators know which fields to check during a rollout.</li></ul></li><li>Planned files: <ul><li><code>pkg/llmproxy/executor/gemini_cli_executor_test.go</code></li><li><code>pkg/llmproxy/auth/gemini/gemini_auth_test.go</code></li><li><code>docs/troubleshooting.md</code></li><li><code>docs/provider-quickstarts.md</code></li></ul></li></ul><h3 id="cpb-0140-normalize-403-metadata-naming" tabindex="-1">CPB-0140 Normalize 403 metadata/naming <a class="header-anchor" href="#cpb-0140-normalize-403-metadata-naming" aria-label="Permalink to &quot;CPB-0140 Normalize 403 metadata/naming&quot;">​</a></h3><ul><li>Status: <code>planned</code></li><li>Implementation deltas: <ul><li>Add a canonical <code>403</code> troubleshooting entry that maps each provider alias to the metadata fields we record (e.g., <code>provider</code>, <code>alias</code>, <code>model</code>, <code>reason</code>) so repeated 403 patterns can be channeled into the same remediation path.</li><li>Bake a short migration note in <code>docs/FEATURE_CHANGES_PLUSPLUS.md</code> (or the nearest changelog) that restates the compatibility guarantee when renaming aliases or metadata fields.</li></ul></li><li>Planned files: <ul><li><code>docs/troubleshooting.md</code></li><li><code>docs/FEATURE_CHANGES_PLUSPLUS.md</code></li></ul></li></ul><h3 id="cpb-0141-iflow-compatibility-gap-closure" tabindex="-1">CPB-0141 iFlow compatibility gap closure <a class="header-anchor" href="#cpb-0141-iflow-compatibility-gap-closure" aria-label="Permalink to &quot;CPB-0141 iFlow compatibility gap closure&quot;">​</a></h3><ul><li>Status: <code>planned</code></li><li>Implementation deltas: <ul><li>Introduce a normalization helper inside <code>pkg/llmproxy/executor/iflow_executor.go</code> (e.g., <code>normalizeIFlowModelName</code>) so requests that carry alternate suffixes or casing are converted before we apply thinking/translators.</li><li>Emit a mini telemetry log (reusing <code>recordAPIRequest</code> or <code>reporter.publish</code>) that tags the normalized <code>model</code> and whether a suffix translation was applied; this will be used by future telemetry dashboards.</li><li>Add focused tests in <code>pkg/llmproxy/executor/iflow_executor_test.go</code> covering the normalized inputs and ensuring the telemetry hook fires when normalization occurs.</li></ul></li><li>Planned files: <ul><li><code>pkg/llmproxy/executor/iflow_executor.go</code></li><li><code>pkg/llmproxy/executor/iflow_executor_test.go</code></li></ul></li></ul><h3 id="cpb-0142-harden-kimi-oauth" tabindex="-1">CPB-0142 Harden Kimi OAuth <a class="header-anchor" href="#cpb-0142-harden-kimi-oauth" aria-label="Permalink to &quot;CPB-0142 Harden Kimi OAuth&quot;">​</a></h3><ul><li>Status: <code>planned</code></li><li>Implementation deltas: <ul><li>Tighten validation in <code>pkg/llmproxy/auth/kimi/kimi.go</code> so empty <code>refresh_token</code>, <code>client_id</code>, or <code>client_secret</code> values fail fast with a clear error and default to safer timeouts.</li><li>Add regression tests in <code>pkg/llmproxy/auth/kimi/kimi_test.go</code> that assert each missing field path returns the new error and that a simulated provider fallback metric increments.</li><li>Document the new validation expectations in <code>docs/troubleshooting.md</code> under the Kimi section.</li></ul></li><li>Planned files: <ul><li><code>pkg/llmproxy/auth/kimi/kimi.go</code></li><li><code>pkg/llmproxy/auth/kimi/kimi_test.go</code></li><li><code>docs/troubleshooting.md</code></li></ul></li></ul><h3 id="cpb-0143-operationalize-grok-oauth" tabindex="-1">CPB-0143 Operationalize Grok OAuth <a class="header-anchor" href="#cpb-0143-operationalize-grok-oauth" aria-label="Permalink to &quot;CPB-0143 Operationalize Grok OAuth&quot;">​</a></h3><ul><li>Status: <code>planned</code></li><li>Implementation deltas: <ul><li>Update <code>docs/provider-operations.md</code> with a Grok OAuth observability subsection that lists the thresholds (latency, failure budget) operators should watch and ties each alert to a specific remediation script or CLI command.</li><li>Add deterministic remediation text with command examples to the <code>docs/troubleshooting.md</code> Grok row.</li><li>Mention the same commands in the <code>docs/provider-operations.md</code> runbook so alerts can point to this lane’s work when Grok authentication misbehaves.</li></ul></li><li>Planned files: <ul><li><code>docs/provider-operations.md</code></li><li><code>docs/troubleshooting.md</code></li></ul></li></ul><h3 id="cpb-0144-provider-agnostic-token-refresh-runbook" tabindex="-1">CPB-0144 Provider-agnostic token refresh runbook <a class="header-anchor" href="#cpb-0144-provider-agnostic-token-refresh-runbook" aria-label="Permalink to &quot;CPB-0144 Provider-agnostic token refresh runbook&quot;">​</a></h3><ul><li>Status: <code>planned</code></li><li>Implementation deltas: <ul><li>Document the provider-agnostic <code>token refresh failed</code> sequence in <code>docs/provider-quickstarts.md</code> and <code>docs/troubleshooting.md</code>, including the <code>stop/relogin/management refresh/canary</code> choreography and sample request/response payloads.</li><li>Reference the existing translation utilities (<code>pkg/llmproxy/thinking</code>) to highlight how they already canonicalize the error so every provider can look at the same diagnostics.</li></ul></li><li>Planned files: <ul><li><code>docs/provider-quickstarts.md</code></li><li><code>docs/troubleshooting.md</code></li></ul></li></ul><h3 id="cpb-0145-process-compose-hmr-deterministic-refresh" tabindex="-1">CPB-0145 Process-compose/HMR deterministic refresh <a class="header-anchor" href="#cpb-0145-process-compose-hmr-deterministic-refresh" aria-label="Permalink to &quot;CPB-0145 Process-compose/HMR deterministic refresh&quot;">​</a></h3><ul><li>Status: <code>planned</code></li><li>Implementation deltas: <ul><li>Extend <code>docs/install.md</code> with a step-by-step process-compose/HMR refresh workflow (touch <code>config.yaml</code>, poll <code>/health</code>, probe <code>/v1/models</code>, run <code>cliproxy reload</code>) using precise commands.</li><li>Introduce a small helper script under <code>scripts/process_compose_refresh.sh</code> that encapsulates the workflow and can be run from CI/local dev loops.</li><li>Explain the workflow in <code>docs/troubleshooting.md</code> so operators have a deterministic repro for <code>Gemini 3</code> refresh failures.</li></ul></li><li>Planned files: <ul><li><code>docs/install.md</code></li><li><code>scripts/process_compose_refresh.sh</code></li><li><code>docs/troubleshooting.md</code></li></ul></li></ul><h3 id="cpb-0146-cursor-root-cause-ux-logs" tabindex="-1">CPB-0146 Cursor root-cause UX/logs <a class="header-anchor" href="#cpb-0146-cursor-root-cause-ux-logs" aria-label="Permalink to &quot;CPB-0146 Cursor root-cause UX/logs&quot;">​</a></h3><ul><li>Status: <code>planned</code></li><li>Implementation deltas: <ul><li>Add a Cursor-specific quickstart entry in <code>docs/provider-quickstarts.md</code> that walks through the <code>cursor login</code> flow, the key indicators of a root-cause <code>cursor</code> error, and the commands to surface structured logs.</li><li>Inject structured logging fields (<code>cursor_status</code>, <code>config_path</code>, <code>response_code</code>) inside <code>pkg/llmproxy/cmd/cursor_login.go</code> so the new quickstart can point operators to log lines that capture the symptom.</li><li>Mention the new log fields in <code>docs/troubleshooting.md</code> so the runbook references the exact columns in logs when diagnosing the <code>cursor</code> root cause.</li></ul></li><li>Planned files: <ul><li><code>docs/provider-quickstarts.md</code></li><li><code>pkg/llmproxy/cmd/cursor_login.go</code></li><li><code>docs/troubleshooting.md</code></li></ul></li></ul><h3 id="cpb-0147-enable-tool-search-qa" tabindex="-1">CPB-0147 ENABLE_TOOL_SEARCH QA <a class="header-anchor" href="#cpb-0147-enable-tool-search-qa" aria-label="Permalink to &quot;CPB-0147 ENABLE_TOOL_SEARCH QA&quot;">​</a></h3><ul><li>Status: <code>planned</code></li><li>Implementation deltas: <ul><li>Add QA scenarios to <code>pkg/llmproxy/executor/claude_executor_test.go</code> that exercise the <code>ENABLE_TOOL_SEARCH</code> flag for both stream and non-stream flows; mock the MCP response that returns <code>tools unavailable 400</code> and assert the fallback behavior.</li><li>Expose the <code>claude.enable_tool_search</code> toggle in <code>config.example.yaml</code> (under the Claude section) and document it in <code>docs/provider-quickstarts.md</code>/<code>docs/troubleshooting.md</code> so rollouts can be staged via config toggles.</li><li>Capture the config toggle in tests by seeding <code>pkg/llmproxy/config/config_test.go</code> or a new fixture file.</li></ul></li><li>Planned files: <ul><li><code>pkg/llmproxy/executor/claude_executor_test.go</code></li><li><code>config.example.yaml</code></li><li><code>docs/provider-quickstarts.md</code></li><li><code>docs/troubleshooting.md</code></li></ul></li></ul><h2 id="verification-strategy" tabindex="-1">Verification Strategy <a class="header-anchor" href="#verification-strategy" aria-label="Permalink to &quot;Verification Strategy&quot;">​</a></h2><ol><li><code>go test ./pkg/llmproxy/executor -run &#39;TestIFlow.*|TestGeminiCLI.*|TestClaude.*ToolSearch&#39;</code></li><li><code>go test ./pkg/llmproxy/auth/gemini ./pkg/llmproxy/auth/kimi -run &#39;TestGeminiAuth|TestKimi&#39;</code></li><li><code>task test:baseline</code> (captures the latency/memory snapshot required by CPB-0138 before/after the doc-driven change).</li><li><code>rg -n &quot;ENABLE_TOOL_SEARCH&quot; config.example.yaml docs/provider-quickstarts.md docs/troubleshooting.md</code></li><li><code>rg -n &quot;cursor_status&quot; pkg/llmproxy/cmd/cursor_login.go docs/troubleshooting.md</code> (ensures the new structured logging message is documented).</li></ol>',26)])])}const p=o(a,[["render",r]]);export{m as __pageData,p as default};
