package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"strings"
	"text/template"

	"github.com/router-for-me/CLIProxyAPI/v6/internal/config"
)

const configTemplate = `// Code generated by github.com/router-for-me/CLIProxyAPI/v6/cmd/codegen; DO NOT EDIT.
package config

// GeneratedConfig contains generated config fields for dedicated providers.
type GeneratedConfig struct {
{{- range .Providers }}
	{{- if .YAMLKey }}
	// {{ .Name | title }}Key defines {{ .Name | title }} configurations.
	{{ .Name | title }}Key []{{ .Name | title }}Key {{ printf "` + "`" + `yaml:\"%s\" json:\"%s\"` + "`" + `" .YAMLKey .YAMLKey }}
	{{- end }}
{{- end }}
}

{{ range .Providers }}
{{- if .YAMLKey }}
// {{ .Name | title }}Key is a type alias for OAICompatProviderConfig for the {{ .Name }} provider.
type {{ .Name | title }}Key = OAICompatProviderConfig
{{- end }}
{{- end }}
`

const synthTemplate = `// Code generated by github.com/router-for-me/CLIProxyAPI/v6/cmd/codegen; DO NOT EDIT.
package synthesizer

import (
	"github.com/router-for-me/CLIProxyAPI/v6/internal/config"
)

// getDedicatedProviderEntries returns the config entries for a dedicated provider.
func (s *ConfigSynthesizer) getDedicatedProviderEntries(p config.ProviderSpec, cfg *config.Config) []config.OAICompatProviderConfig {
	switch p.YAMLKey {
{{- range .Providers }}
	{{- if .YAMLKey }}
	case "{{ .YAMLKey }}":
		return cfg.{{ .Name | title }}Key
	{{- end }}
{{- end }}
	}
	return nil
}
`

func main() {
	providers := config.AllProviders

	data := struct {
		Providers []config.ProviderSpec
	}{
		Providers: providers,
	}

	funcMap := template.FuncMap{
		"title": strings.Title,
	}

	// Generate internal/config/config_generated.go
	generate("internal/config/config_generated.go", configTemplate, data, funcMap)

	// Generate internal/watcher/synthesizer/synthesizer_generated.go
	generate("internal/watcher/synthesizer/synthesizer_generated.go", synthTemplate, data, funcMap)
}

func generate(filename string, tmplStr string, data interface{}, funcMap template.FuncMap) {
	tmpl, err := template.New("gen").Funcs(funcMap).Parse(tmplStr)
	if err != nil {
		log.Fatalf("failed to parse template for %s: %v", filename, err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		log.Fatalf("failed to execute template for %s: %v", filename, err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Printf("Warning: failed to format source for %s: %v\n", filename, err)
		formatted = buf.Bytes()
	}

	// Ensure we are writing to the right place relative to the repo root
	// We assume this is run from the repo root or via go generate
	if err := os.WriteFile(filename, formatted, 0644); err != nil {
		log.Fatalf("failed to write file %s: %v", filename, err)
	}
	fmt.Printf("Generated %s\n", filename)
}
