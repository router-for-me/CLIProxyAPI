package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type ProviderSpec struct {
	Name          string                     `json:"name"`
	YAMLKey       string                     `json:"yaml_key"`
	GoName        string                     `json:"go_name"`
	BaseURL       string                     `json:"base_url"`
	EnvVars       []string                   `json:"env_vars"`
	DefaultModels []OpenAICompatibilityModel `json:"default_models"`
}

type OpenAICompatibilityModel struct {
	Name  string `json:"name"`
	Alias string `json:"alias"`
}

const configTemplate = `// Code generated by github.com/router-for-me/CLIProxyAPI/v6/cmd/codegen; DO NOT EDIT.
package config

import "strings"

// GeneratedConfig contains generated config fields for dedicated providers.
type GeneratedConfig struct {
{{- range .Providers }}
	{{- if .YAMLKey }}
	// {{ .Name | goTitle }}Key defines {{ .Name | goTitle }} configurations.
	{{ .Name | goTitle }}Key []{{ .Name | goTitle }}Key {{ printf "` + "`" + `yaml:\"%s\" json:\"%s\"` + "`" + `" .YAMLKey .YAMLKey }}
	{{- end }}
{{- end }}
}

{{ range .Providers }}
{{- if .YAMLKey }}
// {{ .Name | goTitle }}Key is a type alias for OAICompatProviderConfig for the {{ .Name }} provider.
type {{ .Name | goTitle }}Key = OAICompatProviderConfig
{{- end }}
{{- end }}

// SanitizeGeneratedProviders trims whitespace from generated provider credential fields.
func (cfg *Config) SanitizeGeneratedProviders() {
	if cfg == nil {
		return
	}
{{- range .Providers }}
	{{- if .YAMLKey }}
	for i := range cfg.{{ .Name | goTitle }}Key {
		entry := &cfg.{{ .Name | goTitle }}Key[i]
		entry.TokenFile = strings.TrimSpace(entry.TokenFile)
		entry.APIKey = strings.TrimSpace(entry.APIKey)
		entry.BaseURL = strings.TrimSpace(entry.BaseURL)
		entry.ProxyURL = strings.TrimSpace(entry.ProxyURL)
	}
	{{- end }}
{{- end }}
}
`

const synthTemplate = `// Code generated by github.com/router-for-me/CLIProxyAPI/v6/cmd/codegen; DO NOT EDIT.
package synthesizer

import (
	"github.com/router-for-me/CLIProxyAPI/v6/pkg/llmproxy/config"
)

// getDedicatedProviderEntries returns the config entries for a dedicated provider.
func (s *ConfigSynthesizer) getDedicatedProviderEntries(p config.ProviderSpec, cfg *config.Config) []config.OAICompatProviderConfig {
	switch p.YAMLKey {
{{- range .Providers }}
	{{- if .YAMLKey }}
	case "{{ .YAMLKey }}":
		return cfg.{{ .Name | goTitle }}Key
	{{- end }}
{{- end }}
	}
	return nil
}
`

const registryTemplate = `// Code generated by github.com/router-for-me/CLIProxyAPI/v6/cmd/codegen; DO NOT EDIT.
package config

// AllProviders defines the registry of all supported LLM providers.
// This is the source of truth for generated config fields and synthesizers.
var AllProviders = []ProviderSpec{
{{- range .Providers }}
	{
		Name:    "{{ .Name }}",
		YAMLKey: "{{ .YAMLKey }}",
		GoName:  "{{ .GoName }}",
		BaseURL: "{{ .BaseURL }}",
		{{- if .EnvVars }}
		EnvVars: []string{
			{{- range .EnvVars }}"{{ . }}",{{ end -}}
		},
		{{- end }}
		{{- if .DefaultModels }}
		DefaultModels: []OpenAICompatibilityModel{
			{{- range .DefaultModels }}
			{Name: "{{ .Name }}", Alias: "{{ .Alias }}"},
			{{- end }}
		},
		{{- end }}
	},
{{- end }}
}
`

const diffTemplate = `// Code generated by github.com/router-for-me/CLIProxyAPI/v6/cmd/codegen; DO NOT EDIT.
package diff

import (
	"fmt"
	"github.com/router-for-me/CLIProxyAPI/v6/pkg/llmproxy/config"
)

// BuildConfigChangeDetailsGeneratedProviders computes changes for generated dedicated providers.
func BuildConfigChangeDetailsGeneratedProviders(oldCfg, newCfg *config.Config, changes *[]string) {
{{- range .Providers }}
	{{- if .YAMLKey }}
	if len(oldCfg.{{ .Name | goTitle }}Key) != len(newCfg.{{ .Name | goTitle }}Key) {
		*changes = append(*changes, fmt.Sprintf("{{ .Name }}: count %d -> %d", len(oldCfg.{{ .Name | goTitle }}Key), len(newCfg.{{ .Name | goTitle }}Key)))
	}
	{{- end }}
{{- end }}
}
`

func main() {
	jsonPath := "pkg/llmproxy/config/providers.json"
	configDir := "pkg/llmproxy/config"
	authDir := "pkg/llmproxy/auth"

	if _, err := os.Stat(jsonPath); os.IsNotExist(err) {
		// Try fallback for when run from within the config directory
		jsonPath = "providers.json"
		configDir = "."
		authDir = "../auth"
	}

	data, err := os.ReadFile(jsonPath)
	if err != nil {
		log.Fatalf("failed to read providers.json from %s: %v", jsonPath, err)
	}

	var providers []ProviderSpec
	if err := json.Unmarshal(data, &providers); err != nil {
		log.Fatalf("failed to unmarshal providers: %v", err)
	}

	templateData := struct {
		Providers []ProviderSpec
	}{
		Providers: providers,
	}

	funcMap := template.FuncMap{
		"goTitle": func(name string) string {
			for _, p := range providers {
				if p.Name == name && p.GoName != "" {
					return p.GoName
				}
			}
			return strings.Title(name)
		},
	}

	// Generate config files
	generate(filepath.Join(configDir, "config_generated.go"), configTemplate, templateData, funcMap)
	generate(filepath.Join(configDir, "provider_registry_generated.go"), registryTemplate, templateData, funcMap)

	// Generate synthesizer file
	generate(filepath.Join(authDir, "synthesizer/synthesizer_generated.go"), synthTemplate, templateData, funcMap)

	// Generate diff file
	generate(filepath.Join(authDir, "diff/diff_generated.go"), diffTemplate, templateData, funcMap)
}

func generate(filename string, tmplStr string, data interface{}, funcMap template.FuncMap) {
	tmpl, err := template.New("gen").Funcs(funcMap).Parse(tmplStr)
	if err != nil {
		log.Fatalf("failed to parse template for %s: %v", filename, err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		log.Fatalf("failed to execute template for %s: %v", filename, err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Printf("Warning: failed to format source for %s: %v\n", filename, err)
		formatted = buf.Bytes()
	}

	if err := os.WriteFile(filename, formatted, 0644); err != nil {
		log.Fatalf("failed to write file %s: %v", filename, err)
	}
	fmt.Printf("Generated %s\n", filename)
}
